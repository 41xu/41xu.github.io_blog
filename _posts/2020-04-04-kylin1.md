---
title:	kylin系列（一）从零开始入门kylin（并完成毕设）
tags:	kylin
---

> 大家都知道Apache Kylin很牛逼，在大规模数据量上基本可以实现秒级查询，那么他到底是个啥、为啥我们用kylin（因为毕设技术要求使用5555）、kylin到底咋回事咋用呢？🤔就来了解了解呗～
>
> PS：本文基于kylin1.0

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

## Apache Kylin为什么这么快？

它能解决千亿条、万亿条数据的秒级查询，那么为什么这么快呢？问题的关键就是要解决查询时间随着数据量线性增长的规律。大数据OLAP一般要做的也无非两种情况：

1. 大数据查询一般是统计结果，大多为多条记录经过聚合函数计算得到的统计值，也不是非得要原始记录，访问原始记录的频率也不那么高
2. 聚合是按照维度进行的，一般业务需求往往有限，有意义的维度聚合也有限，不会随着数据膨胀而增长 

所以kylin根据这个得到了一个新思路：**预计算**，即预先计算聚合结果，查询时尽量使用预算结果，避免直接扫描增长可能很多的原始数据。

拿销量这个东西来说，我们要计算某天销量，那就要扫描整张大表然后去做group by, sum() 但是一般销售的东西的数量是相对固定的，可是总的销售数据大表是不断增长的，你在不断增长的大表里查询，查询速度会随着销售数据的增加不断增长。而预计算就可以预先按照维度进行计算然后存储下来，查询某天销量是就可以直接返回了。预计算之后记录数可能只有商品数量那么多，所以肯定是缩小了不少规模的。查询的时候只会随着日期和商品数量增长，不会随销售记录总数增长。

总结一下kylin为什么这么快？就是除了传统大数据分析的**大规模并行处理**和**列式存储**之外还用到了**预计算** 他就比传统的OLAP快了。

## Apache Kylin的工作原理是什么？

Kylin本质采用的是**MOLAP**(Multidimensional Online Analytical Processing)**Cube**，即**多维立方体分析**。既然是多维分析那就先理解一下**维度**和**度量**这两个概念

### 维度是什么？

维度就是观察数据的角度，一般有时间维度、地区维度。一般可以根据维度进行聚合然后分析

### 度量是什么？

度量就是被聚合的统计值，就是聚合和运算的结果。简单的说原始表中的字段里可以被聚合的就是度量

> 上面提到了本质上是MOLAP Cube，那这个Cube又是啥呢？🤔

### Cuboid是什么？

对于每种维度的组合，将度量做聚合运算，运算结果保存为一个**物化视图**，称为Cuboid

### Cube是什么？

Cube就是许多 按维度聚合的物化视图，即**所有维度组合的Cuboid的集合**。

给定一个数据模型，有N个维度的话，这N个维度的所有组合数共有$2^N$种。（这里其实就是N个元素的集合，一共有$2^N$个子集，1个维度组合，2个维度组合，...，N个维度组合，0个维度组合 这样子）

举一个四维Cube的🌰

![](/img/kylin/4DCube.png)

再来一个SQL计算Cuboid的🌰

假设我们现在有time, location,item,supplier四个维度，同时还有一个度量GMV（销量），现在要计算Cuboid[time,location]的SQL语句应该是这样的：

```sql
select time,location,sum(GMV) as GMV 
from Sales 
group by time,location
```

这个计算结果保存为物化视图就是Cuboid

### 讲了这么多kylin的工作原理到底是什么？

Apache Kylin的工作原理就是对数据模型做Cube预计算，利用计算结果加速查询。流程如下：

1. 指定数据模型，定义维度和度量
2. 预计算Cube，计算所有Cuboid并保存为物化视图
3. 执行查询时，读取Cuboid，运算，产生查询结果

 通过上面的描述我们可以看出Kylin查询时并不会扫描原始记录，而是扫描预计计算的结果，这样往往能将查询速度提高一两个数量级，所以超大数据集上优势就更明显了！

## Apache Kylin的系统结构长啥样啊？

Kylin的系统可以分为在线查询和离线构建两部分，技术架构如下图所示

![](/img/kylin/kylin-structure.png)

上半部分是在线查询模块，下半部分是离线构建模块。根据这个图我们大概讲一下离线构建流程。

### 构建流程

首先从Hive里抽取数据，构建Cube。数据应该以关系表的形式输入，并且符合**星型模型(star schema)**。[星型模型就是将存储数据的几张相关表格连接起来，以事实表为核心，连接多个维度表。一般是五个维度。事实表里一般包含于维度表进行连接的外键（但是存在Hive里好像没有外键这个概念）以及用于分析的度量。维度表里只存储了较少的数据量，包含了维度主键和维度表的一些属性。]MapReduce是目前主要的构建Cube技术，构建后的Cube保存到存储引擎中，一般选用HBase。

完成构建之后用户可以从查询系统里发送SQL进行查询分析。SQL语句是根据数据源的关系模型书写的而不是Cube，Kylin在设计时对用户屏蔽了Cube的概念，只要理解了数据源的关系模型就可以了，这让用户操作不那么麻烦。

之后的查询引擎解析SQL，生成基于关系表（就是数据源的关系模型）的逻辑执行计划，然后将其转译为基于Cube的物理执行计划，最后查询预计算生成的Cube并产生结果。整个过程不会访问到原始的数据源。

我们还可以看到查询引擎下方有一个路由选择，这个就是在最初设计kylin是考虑过将kylin不能执行的查询引导hive中执行，但是实践后发现二者的速度差异较大，导致用户体验有点糟糕，所以在发行版本中将路由选择功能默认关闭掉了。

### 可扩展架构

从图里我们不难看出kylin依赖的三大模块，分别是：数据源、构建引擎、存储引擎。最初三者分别为：Hive, MapReduce, HBase。随着Kylin的深入使用，用户们发现他们均有不足之处。

Hive可以替换成Kafka，MapReduce可以替换成Spark，HBase可以替换成Kudu或者Cassandra（啊这些替换的东西都是我没用过的2333）

所以在之后的Kylin1.5版本里，系统架构将三大模块抽象为接口，默认使用Hive, MapReduce, HBase

## 为什么使用Apache Kylin？

~~（因为毕设里的技术要求规定了Kylin啊）~~

为啥使用kylin？那就谈谈他的特性呗。Apache Kylin的主要特点包括：支持SQL接口、支持超大规模数据集、秒级响应、可伸缩性、高吞吐率、可集成BI工具等

Kylin的数据源主要是Hive表，Hive里的查询和SQL差不多，所以Kylin查询就是和写SQL差不多，以关系模型作为支撑。

支持超大数据集无非就是使用了Cube预计算，理论上数据集大小无上限，仅受限于存储系统和分布式计算系统的承载能力，并且规模的局限性主要在维度个数和基数上，一般不会随着数据规模增长而增长。



算了这篇博客就介绍到这里吧，看完这个应该会对Kylin有一定了解了，之后就可以进行Kylin的快速入门，增量构建，流式构建等~~（就可以完成我的毕设啦！）~~

