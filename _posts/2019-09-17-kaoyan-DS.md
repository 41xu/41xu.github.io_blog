---
title:	考研数据结构笔记
tags:	考研 数据结构
---

​    --by @Xusy 徐诗瑶

[TOC]



## 概论

1. 结构=实体+关系；**数据结构=存储+逻辑+运算**

   数据结构：按照**逻辑**关系组织起来的数据，按照特定**存储**方法存在计算机中，在这些数据集上定义了一个**运算**的集合

2. 数据结构的逻辑组织/**逻辑结构**

   - 线性结构：线性表（表、栈、队列、串）
   - 非线性结构：树、图

3. 数据的**存储结构**

   存储结构：逻辑结构到物理存储空间的映射

   四类**逻辑结构**：**顺序、链接、索引、散列**对应存储结构

4. 抽象数据类型 **A**bstract **D**ata **T**ype

   - 定义了一组运算的数学模型
   - 与物理存储结构无关
   - 使软件系统建立在数据之上（面向对象）
   - 模块化思想：隐藏运算实现细节和内部数据结构，软件复用的思想

5. 算法的特性

   算法是对特定问题求解步骤的描述

   - 通用型：保证计算结果正确性，对参数化输入进行问题求解
   - 有效性：算法是有限条指令组成的指令序列
   - 确定性：算法描述中下一步应执行的步骤必须明确
   - 有穷行：算法的执行必须在有限步内结束，不能含有死循环

6. **算法复杂度分析**

   - **大O表示法：**

     - f, g为函数，值域非负实数集，如果存在正数c和$n_0$,使得对于任意的n≥$n_0$，都有f(n)≤cg(n), 称f(n)在集合O(g(n))中，简称f(n)是O(g(n))的，或f(n)=O(g(n))
     - if   $$f \exist c,n_0 >0, s.t.任意n≥n_0: 0≤f(n)≤cg(n)$$
     - n足够大，g(n)是f(n)的上界
     - 大O表示法：表达函数增长率上限，一个函数的增长率上限可能不止一个
     - 当上下限相同时可用$\theta$表示法
     - 加法规则：f1(n)+f2(n)=O(max(f1(n),f2(n)))
     - 乘法规则：f1(n). f2(n)=O(f1(n).f2(n))

   - 大Ω表示法:

     - 存在正数c, $n_0$, 使得对所有n≥$n_0$,都有f(n)≥cg(n)，则称f(n)在集合Ω(g(n))中，或f(n)=Ω(g(n))
     - 采用大Ω表示法时，最好找出在函数增值率的所有下限中最紧的下限（即最大下限）

   - 大$\theta$表示法：

     - 当上下限相同时可用$\theta$表示法
     - $c_1 g(n)≤f(n)≤c_2 g(n)$
     - n足够大，f(n)与g(n)增长率一样

   - $O(n^n) >O(n!) > O(2^n) > O(n^3) > O(n^2) > O(nlog_2n) > O(n) > O(log_2n) > O(1)$

   - 二分法查找k值的时候，分析检索性能是一个树 

     ![1-1](img/1-1.png)

     最大检索长度$\lceil log_2(n+1)\rceil $上取整，平均检索代价$O(logn)$

7. 课后题精选：

  A. 如果函数f(n)是O(g(n))，g(n)是O(h(n))，那么f(n)是O(h(n))

  B. 如果函数f(n)是O(g(n))，g(n)是O(h(n))，那么f(n)+g(n)是O(h(n))

  C. 如果a>b>1，logan是O(logbn), 但logbn不一定是O(logan)

  D. 函数f(n)是O(g(n)),当常数a足够大，一定有函数g(n)是O(af(n))

   解析：

   (1) 根据O()定义可知.
   (2) 如果f(n)是O(g(n))，g(n)是O(h(n)), 则f(n)是O(h(n)),所以f(n)+g(n)是O(h(n))
   (3)logan=log(n)/log(a),logbn=log(n)/log(b),所以前者与后者只差了一个常数项，所以logbn一定是O(logan)
   (4)当f(n)=n,g(n)=n*2, 无论a多大，g(n)都不可能是O(af(n)).

   A,B

8. **逻辑结构与存储结构补充**

   **逻辑结构**就是指数据元素间的逻辑关系，与存储无关，独立于计算机的。（分为线性、非线性结构的但是实际上做题的时候这个不怎么考）

   **存储结构**是数据在计算机中的表示，也称为物理结构。包括顺序存储、链式存储、索引存储、散列存储（这里比如OS中文件系统中文件的不同存储方式）

   **顺序表、哈希表、单链表**表示几种数据结构，即描述了逻辑结构，又描述了存储结构和数据运算

   而**有序表**指关键字有序的线性表，可用链式存可用顺序存，只描述了数据元素间的逻辑关系，因此属于逻辑结构

   **循环队列**是用顺序表表示的队列，是一种数据结构。**栈**是一种抽象数据类型，可用顺序存可用链式存，只表示一种逻辑结构而已。

   数据结构三要素：逻辑、存储、运算

9. `++i & i++`

   ```c++
   int func(int n) {
       int i = 0, sum = 0;
       while (sum < n) {
           sum += ++i;
           cout << sum << " " << i << endl;
       }
       return i;
   }
   ```

   时间复杂度$O(\sqrt n)$

   输出结果：

   ```c++
   1 1
   3 2
   6 3
   10 4
   ```

   `i++`先调用i，后i+1

   `++i` 先i+1

10. 算法原地工作是指算法所需的辅助空间为常量，即O(1)

11. 分析递归算法的时间复杂度时，递归的时间复杂度=栈深*栈宽

    换句话说就是看一共递归压栈几次（就是栈深），每次得执行多久这样的

    当然还是建议通过求递归公式来判断时间复杂度，比如说[王道P9-二-1]

## 线性表

### 线性结构

- 有唯一开始结点，它没有前驱，有唯一一个直接后继；有唯一一个终止结点，有唯一一个直接前驱，没有后继；其他节点称为内部节点，每一个内部节点有且只有一个唯一直接前驱一个唯一直接后继

- 前驱/后继关系r，有反对称性和传递性

- 特点：

  - 均匀性：不同线性表数据元素可以不同，但同一线性表的数据元素必定有相同的数据类型和长度
  - 有序性：各数据元素在线性表中都有自己的位置，并且数据元素间的相对位置是线性的

- 按复杂度划分：

  - 简单的：线性表、栈、队列、散列表
  - 高级的：广义表、多位数组、文件...

- 按访问方式划分：

  - 直接访问型

  - 顺序访问型

  - 目录索引型

    ![](img/1-2.png)

- 按操作划分：

  - 线性表：所有表目都是同一类型结点的线性表；根据存储不同分成：顺序表、链表；不限操作形式
  - 栈 LIFO 
  - 队列 FIFO

### 线性表{$a_0,a_1,...,a_n-1$}

线性表简称表，0个或多个元素的有穷序列

特点：操作灵活，长度可以增长、缩短

#### 线性表逻辑结构

- 包括表长、表头、表尾、当前位置

#### 线性表的存储结构

- 所有表目都是同一类型结点
- 根据存储不同分为：顺序表、链表
- 根据操作分类：线性表（不限制操作）、栈（同一端操作）、队列（两端操作）
- 顺序表结构紧密，存储密度为1

- 线性表运算

### 链表

单链、双链、循环链

#### 单链表

##### 简单单链表

- 第一个节点：head
- 空表判断：`head==NULL`
- 当前节点 cur

##### 带头节点单链表

- 第一个节点：`head->next, head!=NULL`
- 空表判断：`head->next==NULL`

- 查找第i个节点（带头节点）：

  ```c++
  Node *setPos(int i){
    int count=0;
    if(i==-1)
      return head; // i=-1定位到head节点
    Node *p=head-next;
    while(p && count<i){ //写得好妙！循环i次就🉑️，如果是i=0正好就是第一个节点也就是head->next
      count++;
      p=p->next;
    }
    return p;
  }
  ```

- 插入：

  ``` c++
  // 创建新结点
  // 新结点next指向右边结点
  // 左边指向新结点
  bool insert(int val){
    Node *q,*p; // p是当前节点，就是说在p结点后插入
    q=new Node(val,p->next);
    p->next=q;
    if(p==tail)
      tail=q;
    return true;
  }
  ```

- 删除：

  ```c++
  // 当前节点的前驱结点指向当前节点的后继
  // 删除当前节点即可
  // 先从头扫描找到当前节点的前一个节点
  bool delete_(int x){
    Node *p,*q;
    p=head;
    while(p->next!=NULL && p->next->val!=x)
      p=p->next;
    q=p->next;
    if(q==tail){ // 删除的是尾指针则需修改尾指针
      p->next=NULL;
      tail=p;
    }
    else
      p->next=q->next;
    free(q);
  }
  ```
  
- 单链表的运算：对结点操作都要先从head循环找到它，用一个指针指向它

  单链表时间复杂度：定位O(n)、插入O(n)+O(1)、删除O(n)+O(1)

#### 双链表

- 插入：

  ```c++
  // 在p后插入新结点
  new q;
  q->next=p->next; // 本质上和单链表插入一样，都得先指向p后面的结点，不先指过去这个节点就丢了
  p->next=q;
  q->pre=p;
  q->next-pre=q; 
  ```

- 删除：

  ```c++
  // 删除p指向结点
  p->pre->next=p->next;
  p->next->pre=p->pre;
  p->pre=NULL;
  p->next=NULL;
  ```

#### 循环链表

- 单链表/双链表的头尾结点链接起来，就是循环链表

- 没有增加额外存储花销，但为操作带来便利：从循环链表中任意结点出发，都能访问到表中其他结点

  ```c++
  tail->next=head;
  head->pre=tail;
  ```

#### 链表的边界条件

- 几个特殊点处理：
  - head
  - tail->next=NULL // 非循环链表
  - tail->next=head // 循环链表
- 链表处理
  - 空链表特殊处理
  - 插入删除时指针勾链的顺序
  - 查找/插入/遍历时指针的移动

### 顺序表

也称向量，定长的一位数组存储

元素顺序存放在连续地址空间，每个元素有唯一索引值a[0],a[1]这样的

**支持随机访问**

元素地址计算

```c++
loc(ki)=loc(k0)+sizeof(k0)*i
```

#### 顺序表上的运算

- 插入

  ``` c++
  // 在p位插入value
  // 从最后一个开始每个元素向后移一位，从后向前倒
  // 到p位时把这个换成value
  // 实际表长++
  bool insert(int p,int val){
    if(curLen>=maxSize) // 检查表是否溢出
      return false;
    if(p<0 || p>curLen) // 插入位置是否合法
      return false;
    for(int i=curLen;i>p;i--)
      a[i]=a[i-1];
    a[p]=val;
    curLen++; // 增加实际表长这个容易忘！
    return true;
  }
  ```

- 删除

  ```c++
  // 删除p位元素
  // 将p后的每个元素向前移动一位，从p开始直到末
  // 实际表长--
  bool delete_(int p){
    if(curLen<=0) // 检查表是否为空
      return false;
    if(p<0 || p>=curLen) // 检查删除位是否合法
      return false;
    for(int i=p;i<curLen-1;i++) // 这里直到curLen-1，容易出错
      a[i]=a[i+1];
    curLen--;
    return true;
  }
  ```

- 复杂度分析：

  - 插入：移动n-i O(n)
  - 删除：移动n-i-1 O(n)

### 顺序表&链表比较

#### 顺序表

- 没有指针，不用花费额外开销，存储密度为1，整个数组元素很满时，无结构性存储开销
- 支持随机访问，对元素读操作非常简洁
- 插入、删除O(n)，查找O(1)
- 预先申请固定长度连续空间

#### 链表

- 无需事先知道表长
- 允许表长动态变化
- 能够适应经常插入删除内部元素的情况
- 插入、删除O(1)，查找O(n)
- 每个元素都有结构性开销

#### 总结

- 顺序表适合存静态数据

- 链表适合存动态数据

- | n    | 线性表中当前元素数目                 |
  | ---- | ------------------------------------ |
  | P    | 指针的存储单元大小（通常4bytes）     |
  | E    | 数据元素的存储单元大小               |
  | D    | 可以在数组中存储的线性表元素最大数据 |

  空间需求：

  顺序表：DE

  链表：n(P+E)

  当`n>DE/(P+E)`时按顺序表存🉑️

  当`n<DE/(P+E)`时按链表存🉑️

## 栈与队列

操作受限的线性表

### 栈 （运算只在表的一端进行）

Last In First Out

当涉及到逆序输出的时候就可以用栈

- 数组（顺序表实现）叫顺序栈
  - 顺序栈上溢overflow：栈中已经有maxsize个元素，再做进栈操作
  - 顺序栈下溢underflow：对空栈进行出栈运算产生的现象
- 链式存储实现 用单链表方式存储
  - 指针方向从栈顶向下链接
- 顺序栈和链式栈比较
  - 时间效率：所有操作都是常数时间、二者时间效率上难分伯仲
  - 空间效率：顺序栈说明一个固定的长度、链式栈长度可变，但增加结构性开销

一般来说栈不允许读取内部元素，只允许在栈顶操作

**Q: STL中对stack的操作为什么要将`pop()`和`top()`分开？**

A: 如果pop返回栈顶元素，则必须按值返回，不能按引用返回，因为元素已经不存在栈中，必须在引用返回之前将其存到某个地方，如果用动态内存，还得删除这个动态内存，否则会造成内存泄露。而按数值返回效率非常差，因为它包含对栈顶元素的复制构造函数的调用，让pop返回数值会导致潜在的内存问题和效率低下。因此pop光弹栈，不返回栈顶元素。

标答A: 概念上显得清晰；保证一个函数只确定的完成一项特定的功能；使得函数之间的耦合度降低

#### n个元素顺序进栈，多少种出栈顺序计算

n个元素的出栈个数f(n), 不难得到：f(1) = 1, f(2) = 2, f(3) = 5 // 123, 321, 132, 213, 231 

对于f(4):

考虑a,b,c,d四个元素，元素a可能出现在1,2,3,4四个元素（因为进的最早啊，可能出现的情况多啊，想什么时候出去就什么时候出去)

- 当a出现在1时，说明a刚进栈就出栈，那么剩下三个bcd元素，出栈可能数就是f(3)；对应总的可能数就是f(3)
- 当a出现在2时，说明有1个元素比a先出栈，那么这1个元素出栈的f(n)=f(1)，当然这个元素就是b，剩下c,d又变成了f(2)；所以对应总的可能数就是f(1)*f(2)
- 当a出现在3时，说明有2个元素比a先出栈，这2个元素肯定只能是a后面进栈的两个，（因为如果是d先出栈了，那么a肯定轮不到第三个出栈啊！）所以又变成了f(2)，剩下一个元素(d)又变成f(1)；所以对应总的可能数就是f(2)*f(1)

- 当a出现在4时，说明a后面入栈的都出栈了，a是最后一个了，所以a前面出栈的有3个元素，对应可能数就是f(3)；总的可能数也是f(3)

如果我们设f(0)=1，那么就有:

$f(4)=f(0)*f(3)+f(1)*f(2)+f(2)*f(1)+f(3)*f(0)$

   不难发现我们如果用第一个进栈的元素出栈的不同位置进行模拟的话，会得到所有的出栈可能数，即

   $f(n)=\sum_{i=0}^{n-1} f(i)*f(n-1-i)$

   [参考博客](https://blog.csdn.net/Zyearn/article/details/7758716) 

啊上面得到的这个东西叫**卡特兰数**

$f(n)=\frac{(2n)!}{n!(n+1)!}$

#### 栈混洗

栈混洗实际上就是上面说的出栈序列判断的这种题，不过去年考试问的是原始栈A中有`<a1,a2,...,an]`问你某序列是不是A经过一个中间栈S产生的输出序列，这种问题就叫栈混洗。时间复杂度$O(N^2)$

其实就是针对a中元素进展顺序，每进一个就看这个元素和b栈顶能不能对上，对上了就都弹出来，对不上就把a入s，大概就是你脑袋算的过程

代码在这里

```c++
bool stack_mix(queue<char> a, queue<char> b) {
    stack<char> s;
    while (!a.empty()) {
        s.push(a.front());
        a.pop();
        while(!b.empty()){
            if(!s.empty() && b.front()==s.top()){
                cout<<s.top()<<" ";
                s.pop();
                b.pop();
            }
            else break;
        }

        if (b.empty() && s.empty())
            return true;
    }
    return false;
}
int main() {
    string s = "dcefba";
    queue<char> b;
    for (int i = 0; i < s.length(); i++) {
        b.push(s[i]);
    }
    string t = "abcdef";
    queue<char> a;
    for (int i = 0; i < t.length(); i++)
        a.push(t[i]);
    cout << stack_mix(a, b);
    return 0;
}
```

#### --- 10.12 update --- update写还写错了mmp忽略掉它

感觉上面的代码写的不好...所以来更新一下！就是对拍，如果当前input==output表明这个数刚入栈就被弹出来，否则就得把它压栈；如果当前input!=output，那说明当前的input要暂时被压栈，然后看栈顶元素和这个当前output相不相等，相等弹栈，不等说明当前output在栈内，肯定不合法。最后栈空了返回true

```c++
bool stack_valid(vector<int> input, vector<int> output){
    stack<int> s;
    int i=0,j=0;
    while(i<output.size() && j<input.size()){
        if(output[i]==input[j]){
            i++;
            j++;
        }
        else{
            s.push(input[j]);
            j++;
        }
    }
    while(!s.empty() && i<output.size()){
        if(s.top()==output[i]){
            i++;
            s.pop();
        } else return false;
    }
  	if(s.empty() && i==output.size())
    		return true;
  	return false;
}
int main(){
   vector<int> input {1,2,3,4};
   vector<int> output {3,4,1,2}; 
   cout<<stack_valid(input,output);
}
// 3,4,1,2 合法
// 3,4,2,1 不合法
```

通过这样的对拍过程我们不难想到那个教材+PPT上都有的证明题的证明方法，就用和上面一样的想法即可。

#### 数制转换

用栈保存进制转换中的余数，然后逆序输出

```c++
		stack<int> s;
    int a;
    cin>>a;
    // 转八进制
    int b=8;
    while(a>b){
        s.push(a%b);
        a=a/b;
    }
    s.push(a%b);
    while(!s.empty()){
        int x=s.top();
        cout<<x<<" ";
        s.pop();
    }
```

#### 括号匹配

从头扫描字符串，如果遇到左括号，则把其位置编码压入栈中；如果遇到右括号，则与栈顶位置所指的左括号匹配

##### 匹配程序分隔符

类似括号匹配，但是括号多了、或者是/* 这样子

#### 回文游戏

读字符串，去掉空格，压入栈；原串字符与出栈字符依次比较，若不等：非回文；直到栈空都相等：回文

#### 表达式计算

##### 前缀、中缀、后缀表达式

实际上前、中、后缀表达式就是语法树的前、中、后序遍历

+ 前缀：- x + 3 4 5 6 无括号
+ 中缀：(3 + 4) x 5 - 6
+ 后缀：3 4 + 5 x 6 - 无括号，且表达式中运算符按照中缀中出现的次序出现（但是具体位置就不一定还得靠转换算法）

表达式的运算符位于操作数前/中/后对应前/中/后缀

##### 计算中缀表达式的值

两个栈（操作符、操作数），只有当前操作符优先级高于操作符栈栈顶符号的优先级才入栈；否则弹出操作符以及操作数进行计算，直至当前操作符优先级高于栈顶的优先级，然后压栈；操作符栈为空是，操作数栈中剩余的即为运算结果

这个也是扫描到的运算符**优先级高的就压栈**，不然就弹栈

##### ⚠️计算后缀表达式的值⚠️** 这个重要一点！

从**左到右顺序扫描表达式**，遇到操作数，压栈；遇到操作符，连续从栈中退出两个操作数y,x，形成运算指令`x<op>y` 并将结果压栈。扫描完表达式后栈顶元素即为运算结果（次栈顶op栈顶）

##### 计算前缀表达式的值

从**右到左顺序扫描表达式**，遇到操作数，压栈；遇到操作符，连续从栈中退出两个操作数x,y，形成运算指令`x<op>y`并将结果压栈。扫描完表达式后栈顶元素即为运算结果（栈顶op次栈顶）

##### 中缀转后缀

从左到右扫描字符，是数字直接输出；非数字：

	- 右括号：依次弹栈并输出符号，直到遇到左括号
	- 左括号：直接压栈
	- 其他：字符优先级低于栈顶优先级：依次**弹栈**直到遇到比当前字符优先级低的或左括号或空栈，再将当前符号压栈；如果栈顶和当前优先级一样也要弹栈

🌰

```
(3 + 4) * 5 - 6
stack: (
cout: 3
遇到 + 优先级高于( 压栈
stack: ( +
cout: 3 4
遇到 ) 
stack: null
cout: 3 4 +
遇到 * 栈空 压栈 
stack: *
cout: 3 4 + 5 
遇到 - 优先级低于栈顶 弹栈,直到空或优先级低于当前
stack: -
cout: 3 4 + 5 * 6 
最后弹栈
cout: 3 4 + 5 * 6 -
```

总结一下就是**优先级高于栈顶就压栈**，不然就弹栈

##### 中缀转前缀

从右到左扫描字符串，是数字直接输出；非数字：

- 右括号：直接压栈
- 左括号：依次弹栈并输出符号，直到遇到右括号
- 其他：栈空，压栈；栈顶右括号或当前运算符优先级高于或等于栈顶元素，**压栈**；否则弹栈直至高于栈顶

**最后还要把输出串逆置**👈🏿别忘了！

🌰

```
(3 + 4) * 5 - 6
stack: - 
cout: 6 5 
遇到 * 优先级高于 - 压栈
stack: - * ) 
cout: 6 5 4
遇到 + 栈顶右括号，压栈 
stack: - * ) +
cout: 6 5 4 3
遇到（ 弹栈
cout: 6 5 4 3 + * -
然后逆置最终结果： - * + 3 4 5 6
```

总结一下就是**优先级高于栈顶就压栈**，不然就弹栈

##### 其实这里中转前/后缀的话，直接写出来他的语法树然后中/前/后序遍历这样子会更简单点！

#### 深度优先搜索DFS

*之后补充这部分*

#### 递归调用原理

- 阶乘函数为例

  $$\begin{equation}
  f(x)=\left\{
  \begin{aligned}
  n\times f(n-1)  && {n≥1} \\
  1 && {n=0} \\
  \end{aligned}
  \right.
  \end{equation}$$

- 递归出口

  - 递归终止条件，即最小子问题的求解
  - 可以允许多个出口

- 递归规则（递归体+界函数）

  - 将原问题划分成子问题
  - 保证递归规模向出口条件靠拢

- 递归运行时，涉及堆栈的进退 以及通过堆栈传递参数

#### 子程序/函数调用的管理

- 函数调用与递归：
  
- 每个函数包涵的：函数中所有自动变量的内容、函数参数的值、返回地址，称为函数的活动记录，存在栈中
  
- 活动记录通常包括：（PCB） （存在栈中）

  - 参数和局部变量
  - 动态链接：指向调用程序的活动记录的动态链接指针
  - 返回地址
  - 返回值

- 函数运行时的动态存储：

  - 栈Stack：用于分配后进先出的数据，比如说上面的PCB
  - 堆Heap：用于分配不符合FILO的，如指针指向空间的分配

  这个图我一定要放在这里（OS的进程那里涉及到了这个图）

  ![](img/1-3.png)

- 函数调用及返回的步骤（和OS还有机组的中断结合）

  - 调用
    - 保存调用信息（参数、返回地址）
    - 分配数据区（局部变量）
    - 控制转移给被调函数入口
  - 返回
    - 保存返回信息
    - 释放数据区
    - 控制转移到调用函数

#### 消除递归

可以通过循环实现

##### 递归改成非递归

- 递归过程简单、易懂、易写
- 递归过程效率低，重复计算多
- 改为非递归为了提高效率
- 单向递归和尾部递归可直接用迭代实现非递归的转换
- 其他形式必须借助栈

##### 尾部递归

在函数的实现末尾只使用一个递归调用，例如

```c++
void tail(int i){
  if(i>0){
    cout<<i<<" ";
    tail(i-1);
  }
}
```

尾部递归是一个变形的循环

```c++
void iterativeTail(int i){
  for(;i>0;i--)
    cout<<i<<" ";
}
```

##### 非尾部递归

🌰将输入行以相反顺序打印出来

```c++
void reverse(){
  char ch;
  cin.get(ch);
  if(ch!='\n'){
    reverse();
    cout.put(ch);
  }
}
```

非尾部递归转换成非递归：需要用栈进行显示处理

```c++
void nonRecursiveReverse(){
  int ch;
  cin.get(ch);
  while(ch!='\n'){
    st.push(ch); // st是一个全局栈对象
    cin.get(ch);
  }
  while(!st.empty())
    cout.put(st.pop());
}
```

### 队列（运算只在表的两端进行）

First In Last Out

- 顺序队列：关键防止`假溢出` 固定存储空间
  - 普通顺序队列（rear**实指**）
    - 队空: `front=0, rear=-1`
    - 队满:` rear=MaxSize-1`->存在`假溢出`，**假溢出解决**：采用环形队列
    - 插入、删除时通过front和rear来找位置，而不能挪动位置，因此是O(1)
    - 只采用front，rear两个变量，最大容量maxsize-1个数据
  - 环形队列（实指），即front和rear指向队列中实际元素
    - 空队列：front=(rear+1)%size
    - 满队列：因为是实指，所以有个**空块**（要是这块也存上了rear+1==front 没法判断到底是空是满了！所以这个就是**假溢出**
    - ![](img/queue.png)
    - 入队：`rear=(rear+1)%maxSize; sq[rear]=x;`
    - 出队：`front=(front+1)%maxSize; x=sq[front];`
    - 队列中结点个数：`(rear-front+maxSize)%maxSize`
  - **假溢出**解决：
    - 另设一个标志区分队空、队满
    - 少用一个元素空间：队空：front==rear；队满(rea+1)%M=front
    - 这里有一些题目：只用front, rear两个指针标记队列首尾、无法判断队列空/满，因此最大容纳maxSize-1个元素，而增加empty, len这两个变量可以区分两种状态

Q：单链实现队列比双链实现的好处

Q：实指实现

- 链式队列：单链表的方式存储，队列中每个元素对应链表中一个结点
  - 保持队首、尾两个指针

#### 队列应用：打印多项式系数

0 1 2 1 0 1 3 3 1 ...这样子

#### 宽度优先搜索

顶层的所有状态存到队列中，从队首取第一个节点，... 

#### 农夫过河问题

用一个位向量表示（起始）0000->（目标岸）1111这样子 中间有的状态不合法（如1000 狼羊不能共存)

[我觉得这个博客讲的就很清楚](https://blog.csdn.net/u011889952/article/details/44805069)

#### 五人提灯过独木桥

PPT310页

### 递归

递归写出一个递归调用树，然后对这个递归调用树进行中序遍历，也就是深搜

在递归运行时使用递归调用栈进行处理

#### 递归调用树

在分析递归问题的时候，先画个递归调用树，后分析递归调用树，用栈模拟递归调用过程（后调用的得先返回结果，LIFO所以用栈）

*这里PPT203、228页开始有好多题记得练练*

- 🌰f(4)的斐波那契函数的递归调用树，栈模拟递归调用过程

  ![](img/f.png)

  ![](img/fs.png)

- 🌰斐波那契数列f(4)递归调用树，栈模拟递归调用过程

  ![](img/fb.png)

  ![](img/fbs.png)

- 🌰还是斐波那契数列，f(4)计算，其实这里用迭代法算起来比较简单

  ```c++
  #include<vector>
  void fib(int n,vector<int> &a){
      if(n==0){
          a.push_back(0);
          return;
      }
      if(n==1){
          a.push_back(0);
          a.push_back(1);
          return;
      }
      else{
          a.push_back(0);a.push_back(1);
          for(int i=0;i<n;i++)
              a.push_back(a[i]+a[i+1]);
          return;
      }
  }
  int main(){
    	vector<int> a;
    	fib(4,a);
    	cout<<a.back(); //这个时候就会输出fib(4)啦！
  }
  // 很明显上述代码另fib(0)=0; fib(1)=1 这里是一个易错的点，不能写成fib(1)=1,fib(2)=1嗷
  ```

  但是但是但是！如果就让你用一个栈来模拟斐波那契数列递归调用的过程的话，那么其实巨麻烦...具体代码长这样你看看就行：

  ```c++
  class elem{
  public:
      int rt,cn,tn,res; // rt表返回类型, rt=1表调用了第一个递归fib(n-1), rt=2表调用了第二个递归fib(n-2), rt=3表返回了fib(n)的值
      // cn表当前n的值，tn暂存fib(pn-1)的值，即第一个递归的值，res记录fib(cn)的值
  };
  
  int fib_stack(int n){
      stack<elem> s;
      elem t1; // t1表计算fib(n) 将他压栈
      t1.rt=0;
      t1.cn=n;
      t1.tn=-1;
      t1.res=-1;
      s.push(t1);
      while(!s.empty()){
          t1=s.top();
          s.pop();
          if(t1.rt==0){
              if(t1.cn<0) // n值不合法，出错，跳出循环
                  break;
              if(t1.cn<=1){
                  t1.res=t1.cn; // fib(0)=0;fib(1)=1
                  t1.rt=3; // rt=3求得t1.fib(cn)
                  s.push(t1);
              }
              else{
                  t1.rt=1;
                  s.push(t1);
                  elem t2;
                  t2.rt=0;
                  t2.cn=t1.cn-1;
                  t2.tn=-1;
                  t2.res=-1;
                  s.push(t2);
              }
              continue;
          }
          if(t1.rt==3){
              if(s.empty())
                  return t1.res;
              elem t2=s.top();
              s.pop();
              if(t2.rt==1){ //t2调用fib(cn-1)的返回结果
                  t2.cn=t1.res;
                  t2.rt=2;
                  s.push(t2);
                  elem t3;
                  t3.rt=0;
                  t3.cn=t2.cn-2;
                  t3.tn=-1;
                  t3.res=-1;
                  s.push(t3);
                  continue;
              }
              if(t2.rt==2){
                  t2.rt=3;
                  t2.res=t2.tn+t1.res;
                  s.push(t2);
                  continue;
              }
          }
      }
      return -1; // n不合法，出错
  }
  ```

  

#### Hanio问题

*单纯的列进来，挺简单的不细讲了*

#### 一些问题

1. 双向队列可以在队首和队尾进行插入/删除，现有4个不同元素顺序输入到双向队列中，则可得到___种输出：

   1234、1243、1423、1432、4321、4312、4123、4132 -> total: 8
   
2. 只用front, rear两个变量，长度为mSize=n的队列，可容纳的最大元素个数？给出详细推到过程

   A: mSize-1 若最大为mSize-2 则

   ```c++
   (rear + 2) % mSize = front
   (mSize + rear - front - 2) % mSize = 0
   (mSize + rear - front - 1) % mSize = (mSize - 1) % mSize = mSize -1
   ```

   

## 字符串

是一种特殊的线性表，即元素为字符的线性表

线性表的存储方法同样适用于字符串，但是字符串基本元素是字符，如果用链接形式实现的话，有很大的指针的开销，存储结构比较低，不太合适

**字符串String：**由0个或多个字符的顺序排列组成的复合结构，简称串`String`

**串长：**一个字符串包含的字符个数

**空串：**长度为0的串，不包含任何字符内容；空串是任何字符串的子串

**字符char：**组成字符串的基本单位，不同的应用有不同的基础字符集

子串在主串中位置：子串第一个字符相对主串的位置，一般从1开始计

**字符串的顺序存储**：用一个特殊的末尾标记`\0`

**字符串类`class String`存储结构：**

C++里String为了适应字符串长度动态变化的复杂性，不再以字符数组char s[m]的形式出现，而是采用动态变长的存储结构

```c++
class String{
private: 
  char *str;
	int size;  
}
String a;
a="Hello";
// 这里a的str就是Hello，size=5
// 但是字符串在存储时最后要有一个\0
// 所以a实际是这样的：| H | e | l | l | o | \0 |
									 | 0 | 1 | 2 | 3 | 4 | 5 |
```

⚠️注意⚠️：`#include<string.h>`中的串比较函数：`int strcmp(char *s1, char *s2)`是对两个字符串进行ASCII码的比较，s1>s2返回值>0, s1<s2 返回值<0, s1=s2 返回0

### 字符串的存储结构

#### 串长变化不大的

- 用S[0]作为记录串长的存储单元(Pascal)中 

  - **缺点：**限制了串长，char是一个byte, 8bit, 能表示的最大长度是$2^8=256$这么大

- 为存储串的长度，另外开辟一个存储的地方

  - 缺点：串的最大长度一般是静态给出的，不是动态的

- 用一个特殊的末尾标记`'\0'`(C, C++)

  - `#include<string.h>`里采用的这样的存储结构
  - `'\0'`的ASCII字符表编号为0，等价于常量NULL、数字0、false

- 串运算的实现：

  - 求串长度

    ```c++
    int strlen(char d[]){
      int i=0;
      while(d[i]!='\0')
        i++;
      return i;
    }
    ```

  - 字符串复制 

    - 不可以直接用`=`拷贝过去，如果是d=s就是把s的存储地址拷贝了d，这样d保留的字符串空间就消失了

    ```c++
    char *strcpy(char *d, char *s){
      int i=0;
      while(s[i]!='\0'){
        d[i]=s[i];
        i++:
      }
      d[i]='\0' // 最后把d最后一位设置为\0表示结束
      return d;
    }
    ```

  - 字符串比较

    - 采用字典序进行比较

    ```c++
    int strcmp(const char *s1, const char *s2){
      int i=0;
      while(s2[i]!='\0' && s1[i]!='\0'){
        if(s1[i]>s2[i])
          return 1;
        else if(s1[i]<s2[i])
          return -1;
        i++;
      }
      if(s1[i]=='\0' && s2[i]!='\0')
        return -1;
      else if(s2[i]=='\0' && s1[i]!='\0')
        return 1;
      return 0;
    }
    // 更简便的版本
    int strcmp_1(char *s1, char *s2){
      int i;
      for(i=0;s1[i]==s2[i];++i)
        if(s1[i]=='\0' && s2[i]=='\0') // 相等
          return 0; 
      return (s1[i]-s2[i])/abs(s1[i]-s2[i]); // s1>s2 -> 1; s1<s2 -> -1
    }
    ```

### 字符串的一些问题

#### 求子串个数

假设串中每个字符均不相同，n个字符构成的字符串，一共有子串个数为：`n(n+1)/2 +1`个

想法如下：

- 首先！！子串得是**连续**的字符构成的子序列**！！连续！！连续！！！！！！！**

- 包含1个字符的子串共n个
- 包含2个字符的子串共n-1个
- 包含3个字符的子串共n-2个
- 。。。
- 包含n个字符的子串共1个
- **空串1个**
- 综上所述，一共`n+n-1+n-1+...+1+1=n(n+1)/2 +1`个

假设串中出现了重复字符，就得根据不同情况，用所有的子串个数减去重复个数

#### 字符串的一些操作

- concat: 连接两个字符串，连到第一个的结尾

  ![](img/str.png)

  ![](img/str2.png)

  

### 模式匹配算法

串T中查找是否有与串P相等的子串，T为Target（目标串），P为Pattern(模式)

#### 简单模式匹配：BF算法

- 古典的、经典的、朴素的
- 带回溯、速度慢
- 简单匹配算法思想：
  - 将主串T第pos个字符和模式P第一个字符比较：
    - 若相等：继续逐个比较后续字符
    - 若不等：从主串T下一个字符pos+1起，重新与P第一个字符比较
  - 直到T第一个连续子串序列与P相等，返回子串第一个字符的序号，匹配成功
  - 否则匹配失败，返回-1
  - **算法分析：**T长为n, P长为m，最坏情况下，比较次数：(n-m+1)*m // 从头开始比，一直比到最后m个字符，然后发现T的最后一位和P的最后一位不匹配tcl
  - 多数情况下m<<n 因此算法最坏情况的时间复杂度O(n*m)，效率低
  - 最好情况下：
    - 找到了：最好的时候找到了，应该是刚开始比就找到了，比较m次即可，因此算法最好情况的时间复杂度O(m)
    - 没找到：最好的时候没找到，应该是比到了T的最后都没找到，并且要最好的没找到，那就是总是在第一个字符就匹配失败，所以时间复杂度应该是O(n)，比较次数：n-m+1

```c++
int BF(string t,string p){
    int tlen=t.length();
    int plen=p.length();
    if(tlen<plen)
        return -1;
    int i=0,j=0;
    while(i<tlen && j<plen){
        if(t[i]==p[j]){
            i++;
            j++;
        }
        else{
            i=i-j+1; // 不相等，从下一个字符开始匹配
            j=0;
        }
    }
    if(j==plen)
        return i-j;
    else
        return -1;
}
```

#### KMP算法 啊这个是DUT版本

- 无回溯算法（和BF比较你就会发现如果比较`longlongago` 和`longago`,第二次比较时T中o和P中l比，相当于在回溯，事实上应该找T中下一个l比，KMP就是避免了这种回溯

- 那么下次匹配的位置如何确定呢？-> 根据P串的特征值来确定

- 一些先验知识：

  - 前缀子串：模式串P开头的前k个字符, $p_0,p_1,...,p_{k-1}$
  - i位置的后缀子串：在P的第i位的左边，取出k个字符, $p_{i-k+1},...,p_i$
  - 第i位的最长前缀串：与i位置后缀子串相等的最长前缀子串
  - 第i位的最长前缀串长k：就是模式串P在位置i上的**特征数**n[i]
  - 特征数组成的向量（数组）称为该模式串的特征向量
  - 特征向量意义：一旦匹配时$p_i$与$t_j$不想等，可以用P中以n[i-1]为下标的字符与$t_j$比较

- 特征数计算流程（我觉得这个特征数肉眼观察到是挺好观察的，但是计算的话..就按照这个流程背下来吧

  - n[0]=0; 求n[j]=k, j>0

  ![](img/feature.png)

  - 代码实现

  ```c++
  int *feature(string p){
      int *n;
      n=new int[p.length()];
      n[0]=0;
      int k=0;
      for(int j=1;j<p.length();j++){
          k=n[j-1];
          if(p[k]==p[j])
              n[j]=k+1;
          else
              if(k>0) // p[k]!=p[j] 但是你不知道j后缀子串和k前缀能不能匹配上，所以考察范围变成了p[k]
                  n[j]=n[k-1];
              else
                  n[j]=0;
      }
      return n;
  }
  ```

  - 流程的更具体的解释：
    - next[i-1]表示p[i-1]中最大相同前缀子串和后缀子串大小，假设next[i-1]=k，说明前k个字符$p_0,p_1,...,p_{k-1}$和后k个字符$p_{i-k},p_{i-k+1},...,p_{i-2},p_{i-1}$（这样从后往前数了k个字符串）匹配，在查找p[i]时只需看p[i]和p[k]是不是匹配了就可以得到p[i]的next数；
    - 如果p[i]=p[k]，即p[i]=p[next[i-1]]，说明P中0～i 前k+1个字符和后k+1个字符匹配了，next[i]=k+1
    - 那如果p[i]!=p[k] 就是说i-next[i-1]~i 不能和0~next[i-1]匹配，这个时候：
      - 你又不知道i-next[i-1]~i的后缀子串能不能和0~next[i-1]的前缀子串匹配（也就是说只不过代表p[i]不能继续接下去了，最大长度不能++ 但是可能有比较短的那种能互相匹配的子串呀，你不能因为最长的接不下去就把整个长度都给否定了，所以我们试探有么有稍微短点的匹配的子串，就是这里的特征数。就是说考察范围从p[i]变成了p[k] 
      - 感觉讲的还是很迷啊..就这么记吧Orz
      - [这个博客](https://blog.csdn.net/qq_29477855/article/details/51058067) 讲的挺不错啊
      - [还有一个博客讲的也很好的样子](https://blog.csdn.net/qq_37969433/article/details/82947411)

- 知道特征数怎么计算之后，我们在匹配的时候以`t="longlongago",p="longago"`为例，自己模拟一下这个匹配的过程，发现在i=4(t[i]='l'), j=4(p[j]='a')时匹配不上，这个时候就不需要回退了，i也不应改变，我们只需要向右滑动p即可，滑动的位置就应该是j左滑k个，相当于T回退了

```c++
int KMP(string t,string p){
    int *n=feature(p);
    int i=0,j=0;
    while(i<t.length() && j<p.length()){
        if(t[i]==p[j]){
            i++;
            j++;
        }
        else{
            if(j==0)
                i++; // P的第一个字符就和T匹配不上
            else
                j=n[j-1]; // P的中间某个和T匹配不上，这个时候P向右滑即可, 相当于j左移k个
        }
    }
    return i-j>=0?i-j:-1;
}
```

- 算法分析：T长为n, P长为m，KMP的复杂度是O(m+n), feature的复杂度是O(m)，均摊分析

#### KMP算法 PKU版本的

to be continue

## 树与二叉树

### 树

#### 基本概念与术语

- 树：n个节点的有限集，n=0为空树
  - 非空树满足有且仅有一个root，没有直接前驱，但有0个或多个直接后继
  - 其余n-1个节点可划分为m个互不相交的有限集，每个有限集又是一个子树。每个子树的根结点有且仅有1个直接前驱，0个或多个直接后继
- 结点：包含一个数据元素及若干指向子树的分支
- 结点的度：结点拥有的子树个数
- 叶子：度为0的结点
- 路径长度：等于路径通过的结点数-1
- 结点的层次：**根结点层0**，层数逐层递增
- **树深度：**树中结点最大层次
- **树的高度：**深度+1
- 森林：0个或多个**不相交**的树组成的集合

#### 树的基本性质

- 树中结点数=所有结点的度+1
- 度为m的树，第i层上最多有$m^i$个结点，根结点第0层，i>=0
- 高度为h，深度为h-1的度为m的树最多有$\frac{m^h-1}{m-1}$个结点，m>1
- 有n个结点的度为m的树，最小高度$\lceil log_m n(m-1) +1\rceil$ （就是每层都排满这样n个结点排出来的树最矮

#### 树的逻辑表示法

- 树形表示法（就是你最常见的最普通的树）
- 文氏图表示法：用集合的包涵关系描述树结构
- 凹入表示法：用线段的伸缩描述树结构
- 括号表示法/广义表示法：根结点写在左边，根的子节点写在括号里，用逗号分隔描述树结构

### 二叉树

#### 二叉树的概念

##### 具有3个结点的二叉树可能有几种不同形态？

```c++
	1        1       1       1        1
 / \      /       /         \        \
2   3    2       2           2        2
        /         \         /          \
       3           3       3            3
```

##### 具有n个结点的二叉树可能有几种不同形态

上面的问题推广到n个结点，想法和之前的一共多少个出栈序列一样，都是用递推（还是该说递归）的思路

直接贴个[博客链接](https://blog.csdn.net/iG_xdd/article/details/79808519)吧暂时不想写 是卡特兰数

##### 层数、深度、高度

+ 层数：根为第0层，其他节点层数=父节点层数+1
+ 深度：层数最大叶结点的层数
+ 高度：深度+1

##### 满二叉树

###### 下面是王道和我校定义：

二叉树中，所有分支结点都有左子树和右子树，并且所有叶子结点都在同一层

- 特点
  - 高度为k，有$2^k-1$个i结点
  - 每层上的结点数都是最大结点数
  - 所有分支结点度为2
  - 叶子结点都在同一层

###### 下面是PKU定义：

如果一棵二叉树的任何结点，或是树叶，或者恰有两棵非空子树，则此二叉树称为**满二叉树**

![](img/tree.png)

##### 完全二叉树

###### 下面是王道和我校定义：

满二叉树最后一层叶子结点不放满，但是最后一层从左边开始放。

- 特点
  - 叶子结点只可能在最大的两层出现
  - 前k-1层结点都满，第k层结点集中在左边

###### 下面是PKU定义：

- 最多只有最下面的**两层**结点度数可以<2，最下面一层节点都集中在最左边

##### 扩充二叉树

二叉树中出现空的子树时，就增加新的、特殊的结点--空树叶

- 对于原来度为1度结点，下面新增一个空树叶
- 对于原来树叶，下面新增两个空树叶

![](img/kc.png)

- 外部路径长E：扩充二叉树的根到每个外部结点的路径长度之和
- 内部路径长I：扩充二叉树从根到每个内部结点的路径长度之和
- E=I+2n 其中n是内部结点个数，证明方法使用数学归纳法，具体如下：（看PKU课本吧）
  - 当n=1时，I=0，E=2，E=I+2n成立

#### 二叉树的主要性质

1. 在二叉树中，第i层上最多有$2^i$个结点, $i≥0$

2. 深度为k的二叉树最多有$2^{k+1}-1$个结点，其中深度定义为二叉树中层数最大的叶结点的层数

3. 二叉树终端节点数为$n_0$，度为2度节点数为$n_2$，则$n_0=n_2+1$ 

   这个可以用数的节点数=总度数+1来推：

   节点数：$n_0+n_1+n_2$

   总度数：$0*n_0+1*n_1+2*n_2$

   $n_0+n_1+n_2=n_1+2n_2+1 \Longrightarrow n_0=n_2+1 $

4. **满二叉树定理：**非空满二叉树树叶数目=分支节点数+1

5. 满二叉树定理推论：一个非空二叉树的空子树数目=节点数+1

6. 有n个结点（n>0) 得完全二叉树高度$\lceil log_2{(n+1)} \rceil$（深度为$\lceil log_2{(n+1)} \rceil-1$

Q: 扩充二叉树和满二叉树的关系：

#### 二叉树的存储结构

##### 顺序存储

针对满、完全比较ok没有空节点没有浪费空间；针对非完全二叉树要增加空节点，非常不划算

##### 链式存储

- 二叉链表，就是普通Node

```c++
class Node{
public:
  	int data;
  	Node *lchild;
  	Node *rchild;
}
```

n个结点的二叉链表中，有n+1个空指针：n个结点一共2n个指针，n-1条边，所以有n-1个指针非空，n+1个空的

- 这里还有个三叉链表：就是二叉链表加了个`Node *parent;`便于查找父亲，不然就得从头遍历

#### 二叉树的遍历

##### BFS（宽度优先搜索）

```c++
void tree::bfs() {
    queue<Node *> q;
    Node *temp = root;
    q.push(temp);
    while (!q.empty()) {
        temp = q.front();
        cout << temp->data << " ";
        if (temp->lchild)
            q.push(temp->lchild);
        if (temp->rchild)
            q.push(temp->rchild);
        q.pop();
    }
}
```

##### BFS时间复杂度分析

每个结点只被访问一次，时间代价O(n)

非递归保存，入、出栈（队列）正好每个结点入、出一次，O(n)

##### BFS空间复杂度分析

与树最大宽度有关：最好O(1)，最坏O(n)

##### 递归DFS（先、中、后序）（深度优先搜索）

```c++
void tree::preorder(Node *r) {
    if (r) {
        cout << r->data << " ";
        preorder(r->lchild);
        preorder(r->rchild);
    }
}
```

```c++
void tree::inorder(Node *r) {
    if (r == NULL)
        return;
    if (r->lchild)
        inorder(r->lchild);
    cout << r->data << " ";
    if (r->rchild)
        inorder(r->rchild);
}
```

```c++
void tree::postorder(Node *r) {
    if(r){
        postorder(r->lchild);
        postorder(r->rchild);
        cout<<r->data<<" ";
    }
}
```

##### 非递归前序遍历

思想：

- 遇到一个结点，就访问，并把该结点的非空右结点压栈，然后下降遍历左子树。
- 遍历完左子树后从栈顶托出一个结点，并按照该节点的右链接知识的地址再去遍历右子树。

```c++
void tree::pre_formula(){
    stack<Node *>s;
    Node *pointer=root;
    if(pointer)
        s.push(pointer);
    while(!s.empty()){
        cout<<pointer->data<<" ";
        if(pointer->rchild)
            s.push(pointer->rchild);
        if(pointer->lchild)
            pointer=pointer->lchild;
        else{
            pointer=s.top();
            s.pop();
        }
    }
}
```

或者我是这么想的：

- 先把根压栈，对每个栈顶元素自己出栈，打印，然后右孩子压栈，左孩子压栈

```c++
void tree::pre() {
    stack<Node *> s;
    if (root)
        s.push(root);
    while (!s.empty()) {
        Node *temp = s.top();
        cout << temp->data << " ";
        s.pop();
        if (temp->rchild)
            s.push(temp->rchild);
        if (temp->lchild)
            s.push(temp->lchild);
    }
}
```

##### 非递归中序遍历

思想：

- 遇到结点：压栈，遍历左子树
- 遍历完左子树，弹栈并输出；按照其右链地址遍历右子树

实际上你好好感受一下会发现其实这个非递归的前序和中序就是把之前的递归过程用一个函数栈来模拟出来，换句话说就是你好好分析之前的递归树然后得到这些过程把它改成非递归 用了一个函数栈 然后写出来的这个函数，而不是根据你写前/中序表达式这个过程写函数。

```c++
void tree::in_formula() {
    stack<Node *> s;
    Node *temp = root;
    while (!s.empty() || temp) {
        if (temp) {
            s.push(temp);
            temp = temp->lchild;
        } else { // 左子树遍历完了，已经找到最左下方结点了，可以访问他然后退栈了
            temp = s.top();
            cout << temp->data << " ";
            s.pop();
            temp = temp->rchild;
        }
    }
}
```

##### 非递归后序遍历

思想：

- 给栈中元素添加一个特征位，left表示已进入该结点的左子树，将从左边回来；right表示已进入该结点的右子树，将从右边回来

```c++
void tree::post(){
    stackElement element;
    stack<stackElement> s;
    Node *pointer=root;
    while(!s.empty() ||  pointer){
        while(pointer){
            element.pointer=pointer;
            element.tag=Left;
            s.push(element);
            pointer=pointer->lchild;
        }
        element=s.top();
        s.pop();
        pointer=element.pointer;
        if(element.tag==Left){
            element.tag=Right;
            s.push(element);
            pointer=pointer->rchild;
        } else{
            cout<<pointer->data<<" ";
            pointer=NULL;
        }
    }
}
```

##### DFS遍历时间复杂度分析

- 在各种遍历中，每个结点都被访问且只被访问一次，时间复杂度O(n) 

- 非递归保存入出栈时间：
  - 前、中序，某些结点入/出栈一次，不超过O(n)
  - 后序每个结点分别从左、右各入、出一次，但还是O(n)

##### 遍历空间代价分析

- DFS：栈深度与树高度有关
  - 最好：$O(log_2n)$
  - 最坏：$O(n)$

#### 线索二叉树

#### 二叉搜索树

##### 二叉搜索在内存中用途

- 组织内存索引
  - BST是适用于内部存储器的一种重要树形索引
  - 常用红黑树、伸展树等，以维持平衡
  - 外存常用B/B+树
- 保持性质vs保持性能
  - 插入新结点或删除已有结点要保证操作结束仍符合BST定义

#### 平衡二叉树

##### AVL深度与最少节点数

$N_h$表示深度为h时含有的最少结点数，根据AVL的递归定义我们可以得到下面的结论：

$N_0=0,N_1=1,N_2=2,N_h=N_{h-1}+N_{h-2}+1$ 

比如说这么理解：

```
		N
	 / \
tree1 tree2 为了保证节点最少，我们应该让tree1和tree2结点都最少，但还得保持平衡
						tree1、tree2的深度必须得有一个是h-1,另一个h-2就可以这样也是平衡的 
						所以节点数=tree1+tree2+1
```

节点数最少时，所有非叶结点的平衡因子均为1/-1 

最少结点$\iff$最大深度

*AVL树深度N时最多节点当然是个满二叉树*

##### AVL树在内存中用途与效率

- 检索、插入、删除效率都是$O(log_2{n})$
- 有n个结点的AVL高度一定是$O(log n)$
- AVL适用于**组织较小的、内存中的目录**
- 存放在外存储器上的较大文件：B/B+树，尤其B+树

AVL插入删除[一个害可以的博客](https://www.cnblogs.com/MrListening/p/5788842.html)

#### 堆与优先队列

#### Huffman树及应用

#### 在树中查找成功和查找失败的平均查找长度/比较次数

首先明确：**查找长度**其实就是**比较次数**，这两个是一样的（但是和路径长度不同），比较次数要看比较了几个节点（而路径长度要看经过的路径长=比较的节点数-1）

- 查找成功：要找的结点可能是树中任意一个，查找时从根结点出发，开始比较，最少比较1次（即查找的数就在根结点），最多比较高h次，即在最后一层。
- 查找失败：就是说你已经比较到了这棵树的叶子结点，也没找到这个值，或者是你要找一个比a小的而a只有右子树没有左子树这样的，这个时候我们就需要用扩展二叉树来求失败的查找长度。画好扩展二叉树之后，查找长度就是从根到这个扩展节点的父亲节点这么长。

## 图

### 图的基本概念

- 顶点和顶点相邻接，弧和顶点相关联

### 图的存储及基本操作

#### 顺序存储：邻接矩阵

- 邻接矩阵存放n个顶点，$n^2$条边的信息
- 在数据结构中研究的图都是默认顶点自己和自己是不邻接的所以矩阵中对角线是0

##### 邻接矩阵$A^n$含义：

$A^n$的元素$A^n[i][j]$等于由顶点$i$到顶点$j$道长度为$n$的路径的数目。

#### 链式存储：邻接表、邻接多重表

稀疏图可以用邻接表存储

##### 邻接表

邻接表是一种链式存储结构，由一个顺序存储的顶点表和n个链接存储的边表组成



### 图的遍历

#### DFS



### 最小生成树

### 最短路径

#### Dijkstra

##### 算法复杂度

$n$个顶点$e$条边的图，找最短路径的时候对每条边都至少要检查一次

###### 稀疏图

采用最小堆选择权值最小的边, $O(log e)$, 但是每次选择最短路径长度的时候都要对堆进行一次重排（因为会更新最短路，所以得重排）因此时间复杂度为$O((n+e)log e)$

###### 稠密图

#### Floyed

### 拓扑排序

### 关键路径

### 应用

## 查找

### B树、B+树

[一个博客](https://www.cnblogs.com/nullzx/p/8729425.html) 讲的非常好！

#### B树

##### 定义、性质

- m阶B树，意思是一个结点最多能分出去m个子树
- 每个结点最多有m棵子树
- 根结点至少有2棵子树
- 除了根结点的非终端结点**至少**有$\lceil m/2 \rceil$棵子树
- 所有叶子结点都在同一层

##### 删除

- 删除结点元素不止一个的记录，可以直接删掉

<img src="img/Btree1.png" style="zoom:50%;" />

<img src="img/Btree2.png" style="zoom:50%;" />



- 如果删除结点元素中只有一个记录：

  - 向兄弟结点借一个记录，同时修改双亲：

    - 他的双亲结点移下来，兄弟结点移上去

    <img src="img/Btree3.png" style="zoom:50%;" />

    <img src="img/Btree4.png" style="zoom:50%;" />

  - 兄弟结点不够借：要合并相邻结点，并影响双亲结点：

    - 一个双亲移下去，子树数目减少

    <img src="img/Btree5.png" style="zoom:50%;" />

    <img src="img/Btree6.png" style="zoom:50%;" />

    - 双亲移下去了也不行还得继续移双亲合并

    <img src="img/Btree7.png" style="zoom:50%;" />

    <img src="img/Btree8.png" style="zoom:50%;" />

    - 有可能他的父亲也不够借了，这个时候会影响树的高度

    <img src="img/Btree9.png" style="zoom:50%;" />

    <img src="img/Btree10.png" style="zoom:50%;" />

  - 删除的不是叶子结点而是内部结点：

    - 从右子树中找最小的叶子结点/或者是左子树中找最大的，然后值互换，再删掉那个叶子就可以了

#### B+树

##### 定义、性质

m 阶B+树定义如下：

- 每个结点至多有m个字结点
- 每个结点除根外**至少**有$\lceil m/2 \rceil$个字结点
- 根结点至少有2个字结点
- 有k个子结点的结点必有k个关键码

##### 查找

- 查找应该一直到叶结点层，在上层如果已经找到了这个关键码，也要继续向下查找，直到找到了叶结点层的这个关键码
- B+树的叶结点一般链接起来，形成一个双链表



### 不同数据结构适用的查找情况不同

#### 散列表

散列表如果存在内存中，拉链法比较容易实现。但是如果散列表存在磁盘中，每个同义词表的元素可能存在不同的磁盘页中，可能会导致检索一个特定关键码的时候进行了多次磁盘访问，增加了检索时间。这个时候可以用桶式散列方法解决冲突。

#### B+树

## 排序

### 外排序、内排序

#### 任意序列进行基于比较的排序最少比较次数

求最少比较次数应该考虑最坏比较情况

对任意$n$个关键字进行基于比较的排序，在比较完两个关键字之后，仅出现两种可能的转移（交换or不交换）假设整个序列在排序的过程中要做$t$次比较，那么就有$2^t$种情况。而$n$个记录做个排列应该有$n!$中种不同的排列，因此交换的情况必须包含这$n!$种不同的比较路径。于是$2^t≥n! \Longrightarrow t≥log_2{n!}$而$t$为整数，故$t=\lceil log_2{n!} \rceil$